# 考研真题实战之2014年(二分查找)
## 题目描述

42. (15分) 一个长度为$L$($L \ge 1$)的升序序列$S$,处在第「$L/2$」个位置的数称为$S$的中位数.例如,若序列$S1$ = `(11, 13, 15, 17, 19)`,则$S1$的中位数是`15`,两个序列的中位数是含它们所有与秦素的升序序列的中位数.例如$S2$ = `(2, 4, 6, 8, 20)`,则$S1$和$S2$的中位数是`11`.现在有两个等长的升序序列$A$和$B$,设计一个在时间和空间两方面都尽可能高校的算法,找出两个序列$A$和$B$的中位数.要求:
    1. 给出算法的基本设计思想.
    2. 根据设计思想,采用C、C++或Java语言描述算法,关键之处给出注释.
    3. 说明你所设计算法的时间复杂度和空间复杂度.

## 自己解答
### 算法思想
1. 首先将两个序列$A$和$B$合并为一个新的序列$C$，并对$C$进行排序。
2. 若$A$的长度为奇数，则中位数为$C[L/2]$。
2. 设$m$为$C$的长度，因为$A$和$B$的长度相等，则$m$为偶数，中位数为$C[m/2]$。
3. 直接返回$C[m/2]$即可。

### C++代码实现

```c++
// 合并两个等长升序序列A和B，并对合并后的序列C进行排序
void merge(int A[], int B[], int &C[], int n) {
    for (int i = 0; i < n; i++) {
        C[i] = A[i];
        C[i + n] = B[i];
    }
    sort(C, C + 2 * n);
}

// 利用二分查找法在合并后的序列C中查找中位数
int findMedian(int C[], int n) {
    return C[n / 2];
}


```

### 时间复杂度

合并两个序列的时间复杂度为$O(n)$，排序的时间复杂度为$O(n\log n)$，所以总时间复杂度为$O(n\log n)$。

### 空间复杂度

合并两个序列的空间复杂度为$O(n)$，排序的空间复杂度为$O(n)$，所以总空间复杂度为$O(n)$。

## 解析

这个题目所考察的内容是二分查找,但是有两个数组,是双数组的二分查找.因为空间尽可能高校,因此不能再去搞一个大数组,把两个数组合并到一起.这也是自己解答的误区.

### 算法思想
算法的基本设计思想如下:
1. 分别求出$A$和$B$的中位数$a$和$b$;求序列A和B的中文书过程如下:
   1. 若$a=b$, 则$a$或$b$为所求中位数,算法结束
   2. 若$a<b$, 则舍弃序列$A$中较小的一半,同时舍弃序列$B$中较大的一半,要求舍弃的长度相等;
   3. 若$a>b$, 则舍弃序列$A$中较大的一半,同时舍弃序列$B$中较小的一半,要求舍弃的长度相等;
   4. 重复步骤1、2和3,知道两个序列中均只含一个元素,此时中位数为较小值
   

### C++代码实现

```c++
// 求中位数
int findMedian(int A[], int n) {
    return A[n / 2];
}

// 双数组的二分查找
int binarySearch(int A[], int B[], int n) {
    if (n == 1) {
        return std::min(A[0], B[0]);
    }
    
    int mid = n / 2;
    int a = findMedian(A, n);
    int b = findMedian(B, n);
    
    if (a == b) {
        return a;
    }
    
    if (a < b) {
        return binarySearch(A + mid, B, n - mid);
    } else {
        return binarySearch(A, B + mid, n - mid);
}


```
### 时空复杂度
- 时间复杂度: 二分查找的时间复杂度为$O(\log n)$, 所以总时间复杂度为$O(n\log n)$
- 空间复杂度: 算法中只使用了常数个变量, 所以空间复杂度为$O(1)$